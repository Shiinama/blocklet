import "./chunk-CEQRFMJQ.js";

// ../../node_modules/.pnpm/zustand@4.5.0_@types+react@18.2.48_react@18.2.0/node_modules/zustand/esm/shallow.mjs
function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/zustand-computed@1.3.7_react@18.2.0_zustand@4.5.0/node_modules/zustand-computed/dist/mjs/computed.js
var computedImpl = (f, compute, opts) => {
  const trackedSelectors = /* @__PURE__ */ new Set();
  return (set, get, api) => {
    const equalityFn = (opts == null ? void 0 : opts.equalityFn) ?? shallow$1;
    if (opts == null ? void 0 : opts.keys) {
      const selectorKeys = opts.keys;
      selectorKeys.forEach((key) => trackedSelectors.add(key));
    }
    const useSelectors = (opts == null ? void 0 : opts.disableProxy) !== true || !!(opts == null ? void 0 : opts.keys);
    const useProxy = (opts == null ? void 0 : opts.disableProxy) !== true && !(opts == null ? void 0 : opts.keys);
    const computeAndMerge = (state) => {
      const stateProxy = new Proxy({ ...state }, {
        get: (_, prop) => {
          trackedSelectors.add(prop);
          return state[prop];
        }
      });
      const computedState = compute(useProxy ? stateProxy : { ...state });
      for (const k of Object.keys(computedState)) {
        if (equalityFn(computedState[k], state[k])) {
          computedState[k] = state[k];
        }
      }
      return { ...state, ...computedState };
    };
    const setWithComputed = (update, replace, ...args) => {
      ;
      set((state) => {
        const updated = typeof update === "object" ? update : update(state);
        if (useSelectors && trackedSelectors.size !== 0 && !Object.keys(updated).some((k) => trackedSelectors.has(k))) {
          return { ...state, ...updated };
        }
        return computeAndMerge({ ...state, ...updated });
      }, replace, ...args);
    };
    const _api = api;
    _api.setState = setWithComputed;
    const st = f(setWithComputed, get, _api);
    return Object.assign({}, st, compute(st));
  };
};
var computed = computedImpl;
var computed_default = computed;
export {
  computed,
  computed_default as default
};
//# sourceMappingURL=zustand-computed.js.map
